<!doctype html>
<html lang="en">
    <head>
        

        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        
        <link rel="canonical" href="https://blog.precess.io/posts/2021-01-10-van-eck-phreaking.html" />
        

        
        <title>HDMI side-channel attack / 'van Eck Phreaking' - Khalid's blog</title>
        

        

        <link rel="stylesheet" href="../css/default.css" />
        <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Dosis:400,500,700&display=swap" rel="stylesheet">

        <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?config=TeX-AMS_HTML">
        </script>
        <script src="https://kit.fontawesome.com/2f54fe6e45.js" async></script>
    </head>
    <body>
        <header class="logo">
             <div class="logo-container">
             <a href="../" aria-label="notmyspace.io">
                 <div class="logo-content"></div>
             </a>
             </div>
        </header>
        <header class="blog-title">
            <div class="blog-title-container">
                <a href="../">Khalid Aleem's blog</a>
                <div class="byline">"The mind is so complex when you're based, 32 levels. Welcome to my world" - Lil B </div>
            </div>
        </header>

        <nav>
            <div class="sidebar-container">
                <a class href="../">Home</a>
                <a href="#about">About</a>
                <a href="../archive.html">Archive</a>
            </div>
        </nav>

        <main role="main">
            <div class="main-container">
                <article>
    <div class="article-title">
        <h1>HDMI side-channel attack / 'van Eck Phreaking'</h1>
        <div class="byline">
            Posted January 10, 2021
            
        </div>
        <div class="tags">
            
            Tags: <a title="All pages tagged 'digital signal processing'." href="../tags/digital%20signal%20processing.html">digital signal processing</a>, <a title="All pages tagged 'security'." href="../tags/security.html">security</a>
            
        </div> 
    </div>
    <div class="article-body">
        <div class="pandocmd">
<h1 id="abstract">Abstract</h1>
<p>‘van Eck phreaking’ is a side-channel attack involving eavesdropping on a computer display through analysis of correlations in emitted electromagnetic radiation. This report provides background information, covers the analysis procedure, and sucessfully demonstrates this attack up to a distance of 4 metres from a HDMI cable. By processing IQ samples of fixed-bandwidth data at different centre frequencies recorded by an antenna, further analysis reveals that it is indeed possible, through averaging methods, to reconstuct an image that is sufficiently clear to read text on the screen. This has profound and widespread security implications, with security agencies such as the NSA developing the TEMPEST specification to prevent attacks of this nature from compromising secure information.</p>
<!--more-->
<h1 id="introduction">Introduction</h1>
<p>This report reveals that it is indeed possible to eavesdrop on a displayed video feed, and read terminal text, by making use of correlations between the displayed video feed and the associated electromagnetic radiation emitted from a HDMI cable.</p>
<p>We record over a one second duration the emitted radiation and associated background noise from the HDMI cable at a range of different centre frequencies with a fixed bandwidth and sampling frequency. With prior knowledge of the pixel clock, the screen resolution, and blanking intervals, all of which are included within the HDMI protocol, we proceed to reconstruct some approximation to the displayed image by down-sampling our signal to the pixel clock frequency.</p>
<p>Separate frames are aligned by applying minor adjustments to the pixel clock frequency. We take cross-correlations of our down-sampled signal to automate, and verify our adjustments to the pixel clock frequency. We simulate and apply additional noise to model a longer eavesdropping distance to reveal the impact of the image. We then make all the frames coherent, and apply coherent averaging to improve the image quality. We attempt all of the above at different centre frequencies. We observe that it is indeed possible to align and coherently average frames to obtain an image that is sufficiently clean to read text on the screen, provided that the background noise isn’t too large.<br />
</p>
<p>In order to perform the necessary digital signal processing on the data to obtain an image, we make heavy use of the python libraries: <code>scipy.signal</code>, <code>numpy</code>, and <code>matplotlib</code>.</p>
<h1 id="background">Background</h1>
<p>Named after dutch security researcher, Wim van Eck, <em>‘van Eck phreaking’</em> is a side-channel attack to obtain otherwise hidden signals via their correlations with detected electromagnetic radiation that is emitted from a target system. In 1985, van Eck published an analysis of the security considerations associated with the emissions from CRT monitors. Van Eck revealed that it was possible to eavesdrop on the image displayed from a distance of hundreds of metres away with only $15 of radio equipment. It was previously thought that only security agencies could only accomplish this with very expensive equipment.</p>
<p>The term ’phreaking ’originates from eavesdropping, hacking and compromising telephone networks. It is used colloquially to refer to the eavesdropping element of the side channel attack. The research produced by van Eck and others in this area has resulted in fortification measures being taken for the purposes of security. Both the NSA, and NATO have produced the TEMPEST (Telecommunications Electronics Materials Protected from Emanating Spurious Transmissions) specification, to prevent the leakage of electromagnetic radiation from secure sources.</p>
<h1 id="theory">Theory</h1>
<h2 id="iq-samples">IQ samples</h2>
<p>A receiving antenna will pick up radiation at bandwidth, <span class="math inline">\(B\)</span>, at some centre frequency, <span class="math inline">\(f_c\)</span>. The associated band-pass readings are then down-shifted in frequency to the base-band by multiplication with a phasor. In this process, IQ samples are obtained. In this process, the sample rate, <span class="math inline">\(f_s\)</span> is preserved. We obtain an in-phase, <span class="math inline">\(I(t)\)</span>, and quadrature <span class="math inline">\(Q(t)\)</span> component to each sample. Each sample therefore has an associated amplitude, and phase, and may be represented as a phasor.<br />
We can reason about this process in continuous space: <span class="math display">\[\begin{aligned}
  z(t) &amp;= \text{lowpass}(x(t)e^{-i\omega_c t}, B) \\
       &amp;= I(t) + iQ(t) \\\end{aligned}\]</span> More appropriately, we may make the process above discrete for individual samples: <span class="math display">\[\begin{aligned}
  z_n &amp;= \text{lowpass}(x_ne^{-2\pi i f_c \frac{n}{f_s}}, B) \\
  &amp;= I_n + iQ_n\end{aligned}\]</span> Our original band-pass signal, <span class="math inline">\(x_B(t)\)</span> is related to our in phase, and quadrature signals accordingly: <span class="math display">\[\begin{aligned}
  x_B(t) &amp;= \Re{(z(t)e^{i\omega_c t})} \\
         &amp;= \Re(z(t))\cos{\omega_c t} - \Im{(z(t))}\sin{\omega_c t} \\ 
         &amp;= I(t)\cos{\omega_c t} - Q(t)\sin{\omega_c t} \end{aligned}\]</span></p>
<h1 id="experimental-details">Experimental Details</h1>
<h2 id="hdmi-protocol">HDMI protocol</h2>
<p>The HDMI protocol transmits the displayed video frame by frame, line by line, from left to right, one pixel at a time. The data for a single pixel is transmitted in a time period reciprocal to the pixel clock frequency <span class="math inline">\(f_p^{-1}\)</span>. After the image portion of a line is transmitted, the rest of the line is comprised of a <em>horizontal blanking interval</em>, where the remaining pixels may encode audio data, and mark the start of a new line. After the image portion of a full frame is transmitted, the remaining pixels in the frame comprise the <em>vertical blanking interval</em>, which exists to give the receiving device time to process and display the frame before it starts receiving the next one. Given a transmitting mode of some screen resolution and refresh rate, there is an associated pixel clock frequency, horizontal blanking interval, and vertical blanking interval.<br />
As the current in the HDMI cable fluctuates, radiation is emitted. The frequency of radiation emitted is the same as that of the periodic fluctuation, and the amplitude is proportional to that of the amplitude of current fluctuation. Thus, we will observe greater signal strengths corresponding to pixels with a higher average RGB value. This is crucial for image reconstruction.</p>
<h2 id="setup">Setup</h2>
<p>We output a HDMI signal from a Raspberry Pi at a transmitting mode of <span class="math inline">\(640x480@60Hz\)</span>.<br />
Relevant information of the HDMI protocol of this display mode is below: <span class="math display">\[\begin{aligned}
  \text{Mode:}\quad\, &amp; 640\text{x}480\;@\;60\;\text{Hz} \\ 
  \text{Pixel Clock: } f_p &amp;= 25.175 \pm 1\% \text{ MHz} \\
  \text{Horizontal size: } x_t &amp;= 800 \text{ px} \\
  \text{Vertical size: } y_t &amp;= 525 \text{ px}\end{aligned}\]</span> The <a href="#fig:s3-640x480">image displayed</a> contains a desktop environment with a command-line terminal emulator running. We use a <em>Schwarzbeck VUSLP 9111B-039 log-periodic antenna</em>, with a spectral range of (<span class="math inline">\(200-3000\text{ MHz}\)</span>), attached to a <em>Rohde &amp; Schwarz FSV7 signal analyzer</em>, configured to output IQ pairs. The antenna is placed 1 metre away from the HDMI cable. This setup is shown <a href="#fig:s3-antenna-setup">here</a>. Crucially, we expect to measure both the radiation correlating with the signal from the HDMI cable, and background noise of frequencies corresponding to other devices in the room, and other interference effects.</p>
<br>
<figure>
<img src="../images/2021-01-04-vep/project-scene3-antenna-setup.jpg" id="fig:s3-antenna-setup" style="width:300px;">
<figcaption id="fig:s3-antenna-setup" label="fig:s3-antenna-setup">
Schwarzbeck VUSLP 9111B-039 LP antenna, pointed towards the HDMI cable from 1 metre away
</figcaption>
<br> <img src="../images/2021-01-04-vep/project-scene3-640x480.png" id="fig:s3-640x480" style="width:300px">
<figcaption id="fig:s3-640x480" label="fig:s3-640x480">
Raspberry Pi 640x480 HDMI display output
</figcaption>
</figure>
<p><br> Information about the Antenna is as follows; <span class="math display">\[\begin{aligned}
  \text{Sampling frequency: } f_s &amp;= 64 \text{ MHz} \\
  \text{Bandwidth: } B &amp;= 40 \text{ MHz} \\
  \text{Centre frequencies: } f_c &amp;= \{225, 250, ..., 475\} \text{ MHz} \end{aligned}\]</span></p>
<h1 id="analysis">Analysis</h1>
<h2 id="data-format">Data Format</h2>
<p>We obtain data files consisting of IQ samples. The IQ samples are stored in a binary file sequentially as 4 byte floats. These may be read directly from the file. This is performed with the function in the code below.</p>
<div class="sourceCode" id="cb1" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">def</span> load_scene(count, fps, fc_mhz, noise<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  name <span class="op">=</span> <span class="st">&quot;noise&quot;</span> <span class="cf">if</span> noise <span class="cf">else</span> <span class="st">&quot;scene3&quot;</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  dat_filename <span class="op">=</span> <span class="ss">f&quot;</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">-640x480-60-</span><span class="sc">{</span>fc_mhz<span class="sc">}</span><span class="ss">M-64M-40M.dat&quot;</span>    </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  T <span class="op">=</span> count<span class="op">/</span>fps<span class="op">;</span> <span class="co"># Time length to read</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  IQ_COUNT <span class="op">=</span> <span class="bu">int</span>(np.ceil(T <span class="op">*</span> SAMPLE_RATE))<span class="op">;</span> <span class="co"># Total no. of IQ samples</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  data <span class="op">=</span> np.fromfile(dat_filename, dtype<span class="op">=</span><span class="st">'&lt;f4'</span>, count<span class="op">=</span>IQ_COUNT<span class="op">*</span><span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  data <span class="op">=</span> data <span class="cf">if</span> data.size <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> data[:<span class="op">-</span><span class="dv">1</span>]<span class="op">;</span> <span class="co"># Force even length </span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  real <span class="op">=</span> data[<span class="dv">0</span>::<span class="dv">2</span>]<span class="op">;</span> <span class="co"># Every alternate number, offset 0</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  imag <span class="op">=</span> data[<span class="dv">1</span>::<span class="dv">2</span>]<span class="op">;</span> <span class="co"># Every alternate number, offset 1</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>  iq <span class="op">=</span> real <span class="op">+</span> <span class="ot">1.j</span><span class="op">*</span>imag<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>  <span class="cf">return</span> iq, fc_mhz<span class="op">;</span></span></code></pre></div>
<h2 id="naive-approach">Naive Approach</h2>
<p>We start with the centre frequency of <span class="math inline">\(425\,\text{MHz}\)</span>. After reading the data, we resample it to the pixel clock. As such, each index of our resampled array should correspond to an individual pixel on the screen. To resample our data, we apply a hamming window to our fourier transformed data in frequency space to remove the appropriate high frequency components before truncating the frequency space representation and transforming back. This is performed by the <code>scipy.signal.resample</code> function. Lastly, we truncate our pixel array to length <span class="math inline">\(p_t=x_t \times y_t\)</span>, and fill in a 2D array line by line. We plot the magnitude of the phasor for each pixel. This is shown <a href="#fig:s3-naive-noa-nos" data-reference-type="ref" data-reference="fig:s3-naive-noa-nos">below</a>). The relevant code for this is as follows:</p>
<div class="sourceCode" id="cb2" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>TOTAL_FRAMES <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>f_p <span class="op">=</span> <span class="dv">25_175_000</span><span class="op">;</span> <span class="co"># 25.175 MHz (Estimate sample rate)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>z, _ <span class="op">=</span> load_scene(TOTAL_FRAMES, <span class="dv">425</span>, noise<span class="op">=</span><span class="va">False</span>)<span class="op">;</span> <span class="co"># Load 1 frame at 425MHz centre</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>f_r <span class="op">=</span> f_p<span class="op">;</span> <span class="co"># Set resample rate to pixel clock </span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>z_rs <span class="op">=</span> scipy.signal.resample(z, <span class="bu">int</span>(z.size<span class="op">*</span>(f_r<span class="op">/</span>SAMPLE_RATE)), window<span class="op">=</span><span class="st">'hamming'</span>)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>frame <span class="op">=</span> z_rs[:p_t].reshape((y_t, x_t))<span class="op">;</span> <span class="co"># Truncate array, fill frame</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="co"># Plot abs of phasors for a frame.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>plt.imshow(np.<span class="bu">abs</span>(frame), cmap<span class="op">=</span><span class="st">'gray'</span>)<span class="op">;</span></span></code></pre></div>
<p>Further processing is clearly required to make the text in the image legible, in the further sections, we will remove the shear, obtain an appropriate offset, and attempt to average multiple frames to reduce the noise.</p>
<figure>
<img src="../images/2021-01-04-vep/project-425M-naive-noalign-noshift.png" id="fig:s3-naive-noa-nos" style="width:300px;">
<figcaption id="fig:s3-naive-noa-nos" label="fig:s3-naive-noa-nos">
Image obtained from naive approach. Only vague outlines exist. No text is not legible. The image is sheared, incorrectly offset, and noisy.
</figcaption>
</figure>
<h2 id="alignment">Alignment</h2>
<h3 class="unnumbered" id="shear">Shear</h3>
<p>Since the <a href="#fig:s3-naive-noa-nos" data-reference-type="ref" data-reference="fig:s3-naive-noa-nos">image is sheared backwards</a>, we deduce that the pixel clock needs to be increased. We adjust the pixel clock to <span class="math inline">\(f_p = 25.175\text{ MHz} + 25 \text{ kHz}\)</span> to align a <a href="#fig:s3-split-noa-weaks" data-reference-type="ref" data-reference="fig:s3-split-50-noa-weaks">single frame</a>. In order to make our determined pixel clock as accurate as possible, we increase the sensitivity of our heuristic method fifty-fold by stitching the half of the <a href="#fig:s3-split-noa-weaks" data-reference-type="ref" data-reference="fig:s3-split-50-noa-weaks">first and fiftieth frames together</a>). A one-pixel deviation between the first and second frame will now be magnified to a fifty-pixel deviation. Thus, we adjust our pixel clock to:</p>
<p><span class="math display">\[ f_p = 25.175\text{ MHz} + 25.099 \text{ Hz} \]</span></p>
<p>We obtain a perfectly <a href="#fig:s3-split-noa-s" data-reference-type="ref" data-reference="fig:s3-split-50-noa-s">shear-aligned image</a> over 50 frames. This will be useful in the future for the purpose of averaging frames to remove noise. This pixel clock is independent of the centre frequency that the data is obtained from, and thus requires no further case-by-case modification. The necessary code for stitching frames is below:</p>
<div class="sourceCode" id="cb3" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co"># TOTAL_FRAMES=50 in code to load image</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>z_st <span class="op">=</span> np.copy(z_rs)<span class="op">;</span> <span class="co"># Copy resampled array</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>z_f1 <span class="op">=</span> z_st[:p_t]<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>z_st <span class="op">=</span> np.roll(z_st, <span class="op">-</span>p_t<span class="op">*</span>(TOTAL_FRAMES<span class="op">-</span><span class="dv">1</span>))<span class="op">;</span> <span class="co"># Move to last frame</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>z_fL <span class="op">=</span> z_st[:p_t]<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>frame_s <span class="op">=</span> np.concatenate((z_f1[:z_f1.size<span class="op">//</span><span class="dv">2</span>], z_fL[z_fL.size<span class="op">//</span><span class="dv">2</span>:]))</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>            .reshape((y_t, x_t))<span class="op">;</span></span></code></pre></div>
<figure>
<img src="../images/2021-01-04-vep/project-425M-split-50-noalign-weakshift.png" id="fig:s3-split-noa-weaks" style="width:300px;">
<figcaption id="fig:s3-split-50-noa-nos" label="fig:s3-split-noa-weaks">
Stitched image of major adjustment to pixel clock.
</figcaption>
<br> <img src="../images/2021-01-04-vep/project-425M-split-50-noalign-shift.png" id="fig:s3-split-noa-s" style="width:300px;">
<figcaption id="fig:s3-split-noa-s" label="fig:s3-split-noa-s">
Stitched image of major and minor adjustments to pixel clock.
</figcaption>
</figure>
<h3 class="unnumbered" id="offset">Offset</h3>
<p>Despite the fact that our pixel clock is now appropriately set, the first pixel in our readings is not the top-left pixel on the image displayed on the monitor. Since there are <span class="math inline">\(x_t\)</span> samples in one line. Shifting the image offset to the <span class="math inline">\((x, y)\)</span> coordinate on the screen involves moving to the <span class="math inline">\(x + y \times x_t\)</span> index of the array. We observe that the top-left coordinate of the image is sufficiently close to <span class="math inline">\((260, 450)\)</span> as shown <a href="#fig:s3-a-s" data-reference-type="ref" data-reference="fig:s3-a-s">below</a>.</p>
<p>Unfortunately, since the antenna was collecting data at different centre frequencies at different starting times, there will be a different top-left coordinate for data from a different centre frequency on a case-by case basis which must be determined heuristically, with manual tweaking by observation and experimentation. The code for applying the offset is below:</p>
<div class="sourceCode" id="cb4" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co"># Set a for loaded centre frequency from lookup table</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>a <span class="op">=</span> OFFSET_A[fc_mhz]<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>z_rs <span class="op">=</span> np.roll(z_rs, <span class="op">-</span>a)<span class="op">;</span> <span class="co"># Move to appropriate index </span></span></code></pre></div>
<figure>
<img src="../images/2021-01-04-vep/project-425M-align-shift.png" id="fig:s3-a-s" style="width:300px;">
<figcaption id="fig:s3-a-s" label="fig:s3-a-s">
Absolute value of phase for resampled data at centre frequency of 425MHz with appropriate pixel clock and offset. The image is aligned correctly.
</figcaption>
</figure>
<h2 id="correlation">Correlation</h2>
<h3 class="unnumbered" id="determining-x_t-p_t">Determining <span class="math inline">\(x_t, p_t\)</span></h3>
<p>We load and resample 10 frames and take the auto-correlation of the first 5, and the cross-correlation between the first and last 5. From the peaks of the auto-correlation, we may deduce the line size, <span class="math inline">\(x_t\)</span>, and frame size, <span class="math inline">\(p_t\)</span>, of our image. From the periodic peaks of the plots (Figure <a href="#fig:s3-ac-10" data-reference-type="ref" data-reference="fig:s3-ac-10"><span class="math display">\[fig:s3-ac-10\]</span></a>), we correctly deduce that:</p>
<div class="center">
<p><span class="math display">\[\begin{aligned}
      x_t &amp;= 800\text{ px} \\
      p_t &amp;= 420000\text{ px} 
    \end{aligned}\]</span></p>
</div>
<p>The <a href="#fig:s3-cc-xt">peak</a> at <span class="math inline">\(x_t=800\)</span> corresponds to the resampled reciprocal of line frequency <span class="math inline">\(f_h^{-1}\)</span>, the <a href="#fig:s3-cc-pt">peak</a> at <span class="math inline">\(p_t\)</span> corresponds similarly to the frame frequency <span class="math inline">\(f_v^{-1}\)</span> The code for performing correlations is below:</p>
<div class="sourceCode" id="cb5" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co"># Auto-correlation (first 5 frames)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>ac <span class="op">=</span> scipy.signal.correlate(np.<span class="bu">abs</span>(z_rs[:p_t<span class="op">*</span><span class="dv">5</span>]), np.<span class="bu">abs</span>(z_rs[:p_t<span class="op">*</span><span class="dv">5</span>]), method<span class="op">=</span><span class="st">'fft'</span>)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>ac <span class="op">=</span> ac[ac.size<span class="op">//</span><span class="dv">2</span>:]<span class="op">;</span> ac <span class="op">=</span> ac<span class="op">/</span>ac[<span class="dv">0</span>]<span class="op">;</span> <span class="co"># Process plot</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="co"># Cross-correlation (first 5 &amp; last 5)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>cc <span class="op">=</span> scipy.signal.correlate(np.<span class="bu">abs</span>(z_rs[p_t<span class="op">*</span><span class="dv">5</span>:]), np.<span class="bu">abs</span>(z_rs[:p_t<span class="op">*</span><span class="dv">5</span>]), method<span class="op">=</span><span class="st">'fft'</span>)<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>cc <span class="op">=</span> cc[cc.size<span class="op">//</span><span class="dv">2</span>:]<span class="op">;</span> cc <span class="op">=</span> cc<span class="op">/</span>cc[<span class="dv">0</span>]<span class="op">;</span> <span class="co"># Process plot</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>plt.figure()<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>plt.plot(np.arange(x_t<span class="op">*</span><span class="dv">4</span>), ac[:x_t<span class="op">*</span><span class="dv">4</span>], label<span class="op">=</span><span class="st">&quot;Auto-correlation&quot;</span>)<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>plt.plot(np.arange(x_t<span class="op">*</span><span class="dv">4</span>), cc[:x_t<span class="op">*</span><span class="dv">4</span>], label<span class="op">=</span><span class="st">&quot;Cross-correlation&quot;</span>)<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>plt.figure()<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>plt.plot(np.arange(ac.size), ac, label<span class="op">=</span><span class="st">&quot;Auto-correlation&quot;</span>)<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>plt.plot(np.arange(cc.size), cc, label<span class="op">=</span><span class="st">&quot;Cross-correlation&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p>Crucially, we observe that the <a href="#fig:s3-cc-xt" data-reference-type="ref" data-reference="fig:s3-cc-xt">cross-correlation plot</a> has more identifiable peaks, but some constant added. Thicker noise in the plot between the <span class="math inline">\(x_t\)</span> peak exists due to the auto-correlation of noise in the same &amp; multiple lines of the same image. The cross-correlation plot is higher due to the difference in overall noise structure between the first and last 5 frames. We take the correlation of the intensity/abs of each pixel to disregard the phase information, otherwise the correlation plots will oscillate due to phase variations in the image.</p>
<figure>
<img src="../images/2021-01-04-vep/project-425M-cc-10-xt.png" id="fig:s3-cc-xt" style="width:300px;">
<figcaption>
Correlation plots between the first and last 5 frames on the order of <span class="math inline">\(x_t\)</span>.
</figcaption>
<br /> <img src="../images/2021-01-04-vep/project-425M-cc-10-xp.png" id="fig:s3-cc-xp" style="width:300px;">
<figcaption>
Correlation plots between the first and last 5 frames on the order of <span class="math inline">\(p_t\)</span>.
</figcaption>
</figure>
<h3 class="unnumbered" id="shear-automation">Shear automation</h3>
<p>By calculating correlations, the heuristic method for determining the pixel clock may be automated. This can be accomplished by interval bisection. For some estimate of <span class="math inline">\(f_p\)</span>, if our <span class="math inline">\(x_t\)</span> peak exceeds the x-coordinate of <span class="math inline">\(800\)</span>, <span class="math inline">\(f_p\)</span> must be decreased, and the opposite applies conversely. If we repeat this process, we focus in on an appropriate value of <span class="math inline">\(f_p\)</span>.</p>
<div class="sourceCode" id="cb6" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>f_p_U <span class="op">=</span> <span class="dv">25_175_000</span><span class="op">+</span><span class="dv">2_517_500</span><span class="op">;</span> <span class="co"># f_p+1\%</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>f_p_L <span class="op">=</span> <span class="dv">25_175_000</span><span class="op">-</span><span class="dv">2_517_500</span><span class="op">;</span> <span class="co"># f_p-1\%</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>  f_r_est <span class="op">=</span> (f_p_U<span class="op">+</span>f_p_L)<span class="op">/</span><span class="dv">2</span><span class="op">;</span> <span class="co"># Test for midpoint</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>  z1 <span class="op">=</span> np.copy(z)<span class="op">;</span> <span class="co"># Calculate autocorrelation for one frame</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>  rs <span class="op">=</span> scipy.signal.resample(z1, <span class="bu">int</span>(z1.size<span class="op">*</span>(f_r_est<span class="op">/</span>SAMPLE_RATE)), window<span class="op">=</span><span class="st">'hamming'</span>)<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  ac <span class="op">=</span> scipy.signal.correlate(np.<span class="bu">abs</span>(rs), np.<span class="bu">abs</span>(rs), method<span class="op">=</span><span class="st">'fft'</span>)<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  ac <span class="op">=</span> ac<span class="op">/</span>np.<span class="bu">max</span>(ac)<span class="op">;</span> ac <span class="op">=</span> ac[ac.size<span class="op">//</span><span class="dv">2</span>:]<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  idx<span class="op">=</span>x_t<span class="op">//</span><span class="dv">2</span><span class="op">+</span>np.argmax(ac[x_t<span class="op">//</span><span class="dv">2</span>:<span class="dv">3</span><span class="op">*</span>x_t<span class="op">//</span><span class="dv">2</span>])<span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  <span class="bu">print</span>(<span class="st">&quot;Iteration: &quot;</span>,i<span class="op">+</span><span class="dv">1</span>,idx)<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>  <span class="cf">if</span> idx <span class="op">&gt;</span> x_t: <span class="co"># if index of peak exceeds x_t</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    f_p_U <span class="op">=</span> f_r_est<span class="op">;</span> <span class="co"># reduce next f_r</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>  <span class="cf">elif</span> idx <span class="op">&lt;</span> x_t: <span class="co"># if index of peak precedes x_t</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    f_p_L <span class="op">=</span> f_r_est<span class="op">;</span> <span class="co"># increase next f_r</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>  <span class="cf">else</span>:</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    <span class="bu">print</span>(<span class="st">&quot;Optimal Frequency: &quot;</span>, f_r_est)<span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>    <span class="bu">print</span>(<span class="st">&quot;% Deviation from original: &quot;</span>, ((f_r_est<span class="op">-</span><span class="dv">25_175_000</span>)<span class="op">/</span><span class="dv">25_175_000</span>) <span class="op">*</span> <span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>    <span class="bu">print</span>(<span class="st">&quot;% Deviation from perfect: &quot;</span>, ((f_r_est<span class="op">-</span>f_p)<span class="op">/</span>f_p) <span class="op">*</span> <span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a><span class="co"># OUTPUT: ...</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a><span class="co"># Iteration:  7 800</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a><span class="co"># Optimal Frequency:  25214335.9375</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a><span class="co"># % Deviation from original: 0.15625</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a><span class="co"># % Deviation from perfect:  0.05649556178330886</span></span></code></pre></div>
<p>While the result isn’t perfect, no human intervention is required to obtain a result that is around 0.05% off the perfect value obtained for the pixel clock. This is more than enough to fix the shear within an individual frame.</p>
<h2 id="eavesdropping-distance">Eavesdropping distance</h2>
<p>A larger eavesdropping distance than a metre may be modelled by adjusting the noise of the signal. The received power of dipole radiation falls off by <span class="math inline">\(\frac{1}{r^2}\)</span>, and therefore the received amplitude falls off by <span class="math inline">\(\frac{1}{r}\)</span>. As such the background noise signal, <span class="math inline">\(n(t)\)</span> at <span class="math inline">\(r=1\text{\,m}\)</span> may be thought to become <span class="math inline">\(n(t, r) = n(t) \times r\)</span>, as a function of distance. Given appropriate scaling, this is identical to the situation where we consider attenuation of the true signal from the wire. We assume that the background noise is Gaussian, and we obtain a standard deviation from out background readings and use this to model and characterise our noise which we add to our data to simulate a larger eavesdropping distance.<br />
With this model, we observe that an eavesdropping distance exceeding 4-5m is too much to recover a clear signal. This can be verified by looking at the <a href="#fig:s3-noise">frame cross-correlation plots</a>.</p>
<div class="sourceCode" id="cb7" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co"># load z, TOTAL_FRAMES = 2;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="co"># load noise</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>zn, _ <span class="op">=</span> load_scene(TOTAL_FRAMES, f_p<span class="op">/</span>p_t, <span class="dv">425</span>, noise<span class="op">=</span><span class="va">True</span>)<span class="op">;</span> </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>f1 <span class="op">=</span> np.copy(z_rs[:p_t])<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>fL <span class="op">=</span> np.copy(z_rs[p_t<span class="op">*</span>(TOTAL_FRAMES<span class="op">-</span><span class="dv">1</span>):p_t<span class="op">*</span>TOTAL_FRAMES])<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="co"># Average std for x and y of noise phasors</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>noise_std <span class="op">=</span> np.mean([np.std(np.real(zn))), np.std(np.imag(zn))])<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="co"># Apply model </span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>std <span class="op">=</span> noise_std<span class="op">*</span>(eavesdrop_distance<span class="op">-</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a><span class="co"># Apply noise to IQ samples</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>f1 <span class="op">+=</span> np.random.normal(scale<span class="op">=</span>std, size<span class="op">=</span>f1.shape)<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>f1 <span class="op">+=</span> np.random.normal(scale<span class="op">=</span>std, size<span class="op">=</span>f1.shape)<span class="op">*</span><span class="ot">1.j</span><span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>fL <span class="op">+=</span> np.random.normal(scale<span class="op">=</span>std, size<span class="op">=</span>fL.shape)<span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>fL <span class="op">+=</span> np.random.normal(scale<span class="op">=</span>std, size<span class="op">=</span>fL.shape)<span class="op">*</span><span class="ot">1.j</span><span class="op">;</span></span></code></pre></div>
<p><img src="project-425M-cc-noise-xt-4m.png" style="width:90.0%" /></p>
<figure>
<img src="../images/2021-01-04-vep/project-425M-noise-xt-4m.png" id="fig:s3-noise" style="width:300px;">
<figcaption>
Image that would be obtained from an eavesdropping distance of 4 metres.
</figcaption>
<br> <img src="../images/2021-01-04-vep/project-425M-cc-noise-xt-4m.png" style="width:300px;">
<figcaption>
Correlation plots of the first and second frame, the peak at <span class="math inline">\(x_t=800\)</span> is barely visible.
</figcaption>
</figure>
<h2 id="naive-averaging">Naive averaging</h2>
<p>We perform an incoherent average (with no prior phase unrotation) of 10 frames at a <span class="math inline">\(425\text{
  MHz}\)</span> centre frequency, where destructive interference between the phasors comprising each pixel results in the image dimming, and an average of the abs, which reduces noise but does not improve the clarity of text. This can be seen <a href="#fig:s3-incoherent-avg" data-reference-type="ref" data-reference="fig:s3-incoherent-avg">below</a>.</p>
<div class="sourceCode" id="cb8" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co"># load z @ 425M, TOTAL_FRAMES=10</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>FRAMES <span class="op">=</span> np.array([z_rs[p_t<span class="op">*</span>i:p_t<span class="op">*</span>(i<span class="op">+</span><span class="dv">1</span>)]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(TOTAL_FRAMES)])<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="co">#FRAMES = np.abs(FRAMES); # Uncomment for z_m = AVG of ABS of FRAMES</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>z_m <span class="op">=</span> np.mean(FRAMES, axis<span class="op">=</span><span class="dv">0</span>).reshape((y_t, x_t))<span class="op">;</span></span></code></pre></div>
<figure>
<img src="../images/2021-01-04-vep/project-425M-incoherent-avg-10.png" id="fig:s3-incoherent-avg" style="width:300px">
<figcaption>
Absolute value of incoherent average of 10 frames. We observe overall dimming of the image.
</figcaption>
<br> <img src="../images/2021-01-04-vep/project-425M-abs-avg-10.png" id="fig:s3-abs-avg" style="width:300px">
<figcaption>
Average of absolute values of 10 frames. We do not observe an increase in clarity of text.
</figcaption>
</figure>
<h2 id="coherent-averaging">Coherent Averaging</h2>
<p>To view the phase for each pixel, we perform a <a href="fig:s3-hsv-a">HSV plot</a> of the image, where the phase is the hue, the saturation is set to 1, and the value is set to the amplitude of the phasor.</p>
<div class="sourceCode" id="cb9" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">def</span> frame_hsv(frame):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    frame <span class="op">=</span> frame<span class="op">/</span>np.<span class="bu">max</span>(np.<span class="bu">abs</span>(frame))<span class="op">;</span> <span class="co">#Normalize</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="co"># Linearly map range [-pi,pi] to [0,1]</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>    H <span class="op">=</span> (((np.angle(frame)<span class="op">/</span>np.pi)<span class="op">+</span><span class="dv">1</span>)<span class="op">/</span><span class="dv">2</span>).reshape((y_t, x_t))<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    S <span class="op">=</span> np.ones((y_t, x_t))<span class="op">;</span> <span class="co"># Max saturation</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    V <span class="op">=</span> np.<span class="bu">abs</span>(frame).reshape((y_t, x_t))<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    z_m2 <span class="op">=</span> np.concatenate(([np.copy(H)], [np.copy(S)], [V]))<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    z_m2 <span class="op">=</span> np.moveaxis(z_m2, <span class="dv">0</span>, <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    <span class="im">import</span> matplotlib.colors</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    z_m2 <span class="op">=</span> matplotlib.colors.hsv_to_rgb(z_m2)<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>    <span class="cf">return</span> z_m2<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>plt.imshow(frame_hsv(z_rs[:p_t]))<span class="op">;</span></span></code></pre></div>
<figure>
<img src="../images/2021-01-04-vep/project-425M-hsv.png" id="fig:s3-hsv-a" style="width:300px;">
<figcaption>
Phase variation of the 425M centre frequency signal shown as a HSV plot.
</figcaption>
<br> <img src="../images/2021-01-04-vep/project-425M-specgram.png" id="fig:s3-specgram" style="width:300px;">
<figcaption>
Spectrogram of the 425M signal, we observe peaks at our pixel clock frequencies.
</figcaption>
</figure>
<p>In order to perform coherent averaging, we must ensure that the phase is the same at the start of each pixel. Further, to improve the clarity of the text, we shift our centre frequency to that of the pixel clock, one of the two bright lines in the <a href="fig:s3-specgram">spectrogram below</a> To finely adjust the frequency shift, we use identical code to the heuristic <span class="math inline">\(f_p\)</span> alignment earlier, attempting to match the hue of the first, and last frame. In this section, we perform coherent averaging with a centre frequency of <span class="math inline">\(425\text{\,MHz}\)</span>, as the image looks <a href="#fig:s3-coherent-avg">significantly better</a>. We can automate this process by performing a low-pass filter of the phase angle across multiple frames. We seek to remove the steepest low-frequency peak. This can, again, be accomplished by interval bisection, similarly to the method of automatically determining <span class="math inline">\(f_p\)</span>.</p>
<div class="sourceCode" id="cb10" data-fontsize="\tiny" data-breaklines><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">#f_k = [HEURISTICALLY DETERMINED SHIFT FREQUENCY]</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>z, f_mhz <span class="op">=</span> load_scene(TOTAL_FRAMES, f_p<span class="op">/</span>p_t, <span class="dv">400</span>, <span class="va">False</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>f_s <span class="op">=</span> f_k<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>z <span class="op">=</span> z <span class="op">*</span> np.exp(<span class="ot">1.j</span> <span class="op">*</span> <span class="dv">2</span><span class="op">*</span>np.pi <span class="op">*</span> f_s<span class="op">/</span>SAMPLE_RATE <span class="op">*</span> np.arange(z.size))<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co"># DOWNSAMPLE AND PLOT HSV/ABS, PERFORM NAIVE AVERAGE</span></span></code></pre></div>
<figure>
<img src="../images/2021-01-04-vep/project-425M-hsv-avg-10.png" id="fig:s3-coherent-avg" style="width:300px;">
<figcaption>
HSV plot, with signal frequency shifted to an <span class="math inline">\(f_p\)</span> peak. Minor adjustment to frequency shift guarantees coherence of phase across pixels. This is shown by the solid colors. After coherent averaging, the terminal text is clearly legible.
</figcaption>
<br>
</figure>
<h1 id="results">Results</h1>
<h2 id="alternative-centre-frequencies">Alternative centre frequencies</h2>
<p>To obtain coherent averages at alternative centre frequencies, we can calculate our major frequency shift from <span class="math inline">\(f_k\)</span> determined for one centre frequency. Crucially, we must still use our heuristic method to determine the appropriate minor frequency shift to guarantee phase coherence across all frames before averaging, and <a href="#fig:s3-co-avg-3">plotting the absolute values</a>.</p>
<p>Out of our best plots, it is clear that the signal at <span class="math inline">\(f_c = 400\text{ MHz}\)</span> is the most clear. Both the text in the terminal, and ‘<em>the quick brown f</em>’, at the bottom right, can be read from the image.</p>
<p>No signal was obtained from centre frequencies <span class="math inline">\(f_c = 225, 250\text{ MHz}\)</span>. As a result, no further processing was performed with these.</p>
<figure id="fig:s3-co-avg-3">
<img src="../images/2021-01-04-vep/project-325M-co-avg-3-abs.png" style="width:300px;">
<figcaption>
325M
</figcaption>
<br> <img src="../images/2021-01-04-vep/project-350M-co-avg-3-abs.png" style="width:300px;">
<figcaption>
350M
</figcaption>
<br> <img src="../images/2021-01-04-vep/project-400M-co-avg-3-abs.png" style="width:300px;">
<figcaption>
400M
</figcaption>
<br> <img src="../images/2021-01-04-vep/project-450M-co-avg-3-abs.png" style="width:300px;">
<figcaption>
450M
</figcaption>
<br>
<figcaption>
Absolute values of the best 3-frame average of pixel-clock frequency shifted and coherently aligned readings from different centre frequencies.
</figcaption>
<br>
</figure>
<h1 id="conclusion">Conclusion</h1>
<p>We deduce that it is indeed possible to eavesdrop on a HDMI signal by analysing the radio spectrum with an antenna a metre away. While the standard van Eck phreaking attack involves eavesdropping on the display output of CRT monitors, it is still possible to detect the associated correlations in the radiation emitted by a HDMI cable upon the transmission of an image.</p>
<p>While it is possible to detect some form of intensity for the pixels, this is not the true brightness of the pixels and it is not possible to obtain any information about the color of the pixels.</p>
<p>Moreover, since sufficient accuracy can be obtained from the signal for that of a single frame, it should in principle be possible to eavesdrop on a display in real-time. This can be done by feeding the antenna output, for the most appropriate center frequency, into an FPGA with a custom hardware pipeline to process the data in real-time.</p>
<p>Appropriately encrypted data has a uniform probability distribution, and will therefore resemble noise. As such, an attack of this nature can be mitigated with private keys stored in the monitor hardware, and a public-key encrypted video feed transmitted through the HDMI cable. However, this comes with an associated computational barrier and performance penalty.</p>
</div>
<style>
    .pandocmd figure {
        display: flex;
        align-items: center;
        flex-direction: column;
    }
   .pandocmd figure img {
       border: 3px dashed grey;
   }
   .pandocmd figcaption{
   margin-top:10px;
  font-family: 'Lora';
    font-size: small; 
   }
    
   .pandocmd pre code {
      padding: 0;
      overflow: visible;
    }
    .pandocmd div.sourceCode {
       padding: 10px;
       border: 2px dashed #6d6964;
    }
   .pandocmd .sourceCode {
       font-size: small;
       font-family: monospace;
     background-color: white;
     overflow: visible;
    }
    .pandocmd code{white-space: pre-wrap;
        font-family: monospace;
    }
    .pandocmd span.smallcaps{font-variant: small-caps;}
    .pandocmd span.underline{text-decoration: underline;}
    .pandocmd div.column{display: inline-block; vertical-align: top; width: 50%;}
    .pandocmd div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    .pandocmd ul.task-list{list-style: none;}
    .pandocmd pre > code.sourceCode { white-space: pre; position: relative; }
    .pandocmd pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    .pandocmd pre > code.sourceCode > span:empty { height: 1.2em; }
    .pandocmd .sourceCode { overflow: visible; }
    .pandocmd code.sourceCode > span { color: inherit; text-decoration: inherit; }
    .pandocmd div.sourceCode { margin: 1em 0; }
    .pandocmd pre.sourceCode { margin: 0; }
    @media screen {
    .pandocmd div.sourceCode { overflow: auto; }
    }
    .pandocmd pre.numberSource code
      { counter-reset: source-line 0; }
    .pandocmd pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    .pandocmd pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    .pandocmd pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    .pandocmd div.sourceCode
      {   }
    @media screen {
    .pandocmd pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    .pandocmd code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    .pandocmd code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    .pandocmd code span.at { color: #7d9029; } /* Attribute */
    .pandocmd code span.bn { color: #40a070; } /* BaseN */
    .pandocmd code span.bu { } /* BuiltIn */
    .pandocmd code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    .pandocmd code span.ch { color: #4070a0; } /* Char */
    .pandocmd code span.cn { color: #880000; } /* Constant */
    .pandocmd code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    .pandocmd code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    .pandocmd code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    .pandocmd code span.dt { color: #902000; } /* DataType */
    .pandocmd code span.dv { color: #40a070; } /* DecVal */
    .pandocmd code span.er { color: #ff0000; font-weight: bold; } /* Error */
    .pandocmd code span.ex { } /* Extension */
    .pandocmd code span.fl { color: #40a070; } /* Float */
    .pandocmd code span.fu { color: #06287e; } /* Function */
    .pandocmd code span.im { } /* Import */
    .pandocmd code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    .pandocmd code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    .pandocmd code span.op { color: #666666; } /* Operator */
    .pandocmd code span.ot { color: #007020; } /* Other */
    .pandocmd code span.pp { color: #bc7a00; } /* Preprocessor */
    .pandocmd code span.sc { color: #4070a0; } /* SpecialChar */
    .pandocmd code span.ss { color: #bb6688; } /* SpecialString */
    .pandocmd code span.st { color: #4070a0; } /* String */
    .pandocmd code span.va { color: #19177c; } /* Variable */
    .pandocmd code span.vs { color: #4070a0; } /* VerbatimString */
    .pandocmd code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .pandocmd .display.math{display: block; text-align: center; margin: 0.5rem auto;}


</style>
    </div>
</article>

            </div>
        </main>

        <footer id="about">
            <section class="footer-box">
                <h2>About me</h2>
<p>I'm currently a fourth year student studying Computer Science at Trinity College, Cambridge. </p>

            </section>
            <section class="footer-box">
                <h2>Contact</h2>
<ul class="fa-ul">
    <li>
        <a href="mailto:me+blog@precess.io" aria-label="Email"><i class="fa-li fas fa-envelope"></i></a>
        Email me at <a href="mailto:me+blog@precess.io" class="email">me+blog@precess.io</a>
    </li>
    <li>
        <a href="https://instagram.com/shinyhappysquidward" aria-label="Instagram"><i class="fa-li fab fa-instagram"></i></a>
        Follow me on Instagram at <a href="https://instagram.com/shinyhappysquidward">@shinyhappysquidward</a>
    </li>
    <li>
        <a href="https://github.com/Skydive/" aria-label="GitHub"><i class="fa-li fab fa-github"></i></a>
        See my programming projects on <a href="https://github.com/Skydive/">GitHub</a>
    </li>
</ul>

            </section>
            <section class="footer-box">
                <h2>This site</h2>
<p>Content provided under a <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons CC BY 4.0</a> license.
<p>Thanks to <a href="https://github.com/thjread/thjread-blog">Thomas Read</a> for the theme.
<p>This site is generated by <a href="https://jaspervdj.be/hakyll/">Hakyll</a></p>

            </section>
        </footer>
    </body>
</html>
